/*CopyrightHere*/
package repast.simphony.freezedry;

import org.apache.commons.lang3.StringEscapeUtils;
import simphony.util.messages.MessageCenter;

import java.util.*;

public abstract class AbstractDataSource<X> implements FreezeDryedDataSource {
	/**
	 * This should be pre-pended to column names that will be interpreted in a "special" way (IE
	 * used to identify an object, or as a reference to another table).
	 */
	public static final String SPECIAL_COL_MARKER = "_SCM_";

	/**
	 * Marker for children column names (should be appended to the column name).
	 */
	public static final String CHILDREN_MARKER = "_CHILDREN";

	/**
	 * Marker for byte storage column names (should be appended to the column name).
	 */
	public static final String BYTES_MARKER = "_BYTESSTORAGE";

	/**
	 * Marker for class types column names (should be appended to the column name).
	 */
	public static final String CLASS_MARKER = FreezeDryer.CLASS_MARKER;

	/**
	 * Marker for child id column names (should be appended to the column name).
	 */
	public static final String CHILD_ID_MARKER = FreezeDryer.ID_MARKER;

	/**
	 * Name of the column used to identify objects.
	 */
	public static final String ID_COL = SPECIAL_COL_MARKER + "OBJ_ID";

	/**
	 * In child tables, this is the parent's identifier column.
	 */
	public static final String PARENT_ID_COL = "parentid";

	/**
	 * In child tables, this is the child's class column.
	 */
	public static final String CHILD_CLASS_COL = "childclass";

	/**
	 * In child tables, this is the child's id column.
	 */
	public static final String CHILD_ID_COL = "childid";
	
	public static final String ARRAY_MARKER = "ARRAY";
	
	/**
	 * This is called at the start of a call to write. This should cause any needed preparation for
	 * reading this type to occur. It will be followed by calls to
	 * {@link #writeRow(FreezeDryedObject, Map)} and a call to
	 * {@link #finishTypeWrite(FreezeDryedObject)}.
	 * 
	 * @param fdo
	 *            the {@link FreezeDryedObject} who will begin to be written
	 * @throws FreezeDryingException
	 *             when there's an error
	 */
	protected abstract void startTypeWrite(FreezeDryedObject fdo) throws FreezeDryingException;

	/**
	 * This writes a row of data out which was generated by the specified {@link FreezeDryedObject}.
	 * This will be preceded by a {@link #startTypeWrite(FreezeDryedObject) call and will be 
	 * followed by calls to {@link #writeRow(FreezeDryedObject, Map)} and a call to
	 * {@link #finishTypeWrite(FreezeDryedObject)}.
	 * 
	 * @param fdo
	 *            the {@link FreezeDryedObject} that the row of data came from
	 * @param row
	 *            the data for the specified {@link FreezeDryedObject}
	 * @throws FreezeDryingException
	 *             when there's an error
	 */
	protected abstract void writeRow(FreezeDryedObject object, Map<String, Object> row)
			throws FreezeDryingException;

	/**
	 * Writes a byte array retrieved from the specified {@link FreezeDryedObject} with the specified
	 * fieldName.
	 * 
	 * @param fdo
	 *            the source of the data
	 * @param fieldName
	 *            the field this data is assosciated with
	 * @param bs
	 *            the data itself
	 * @return the value to be written to the subclass for the fieldName (this could potentially
	 *         just be an id, or it could just be the bytes themselves)
	 * @throws FreezeDryingException
	 */
	protected abstract Object writeByteArray(FreezeDryedObject fdo, String fieldName, byte[] bs)
			throws FreezeDryingException;

	/**
	 * Initiates the writing of the children for the specified {@link FreezeDryedObject}.
	 * 
	 * @param fdo
	 *            the {@link FreezeDryedObject whose children will be written
	 * @throws FreezeDryingException
	 */
	protected abstract void startChildrenWrite(FreezeDryedObject fdo) throws FreezeDryingException;

	/**
	 * Writes the data for a child of the specified {@link FreezeDryedObject}.
	 * 
	 * @param fdo
	 *            the parent
	 * @param child
	 *            the data from the child
	 * @throws FreezeDryingException
	 */
	protected abstract void writeChildData(FreezeDryedObject fdo, HashMap<String, Object> child)
			throws FreezeDryingException;

	/**
	 * Finishes the writing of the children for the specified {@link FreezeDryedObject}.
	 * 
	 * @param fdo
	 *            the {@link FreezeDryedObject whose children were written
	 * @throws FreezeDryingException
	 */
	protected abstract void finishChildrenWrite(FreezeDryedObject object)
			throws FreezeDryingException;

	/**
	 * Finishes the writing of the specified {@link FreezeDryedObject}. This will be preceded by a
	 * {@link #startTypeWrite(FreezeDryedObject) call and calls to 
	 * {@link #writeRow(FreezeDryedObject, Map)} (along with the other child and byte methods).
	 * 
	 * @param fdo
	 *            the {@link FreezeDryedObject} that the row of data came from
	 * @throws FreezeDryingException
	 *             when there's an error
	 */
	protected abstract void finishTypeWrite(FreezeDryedObject object) throws FreezeDryingException;

	/**
	 * Initiates the reading of the specified class. This class represents is of a type that was at
	 * some point written out through a {@link FreezeDryedObject}.
	 * 
	 * @param clazz
	 *            the class that was the type returned by {@link FreezeDryedObject#getType()}
	 * @throws FreezeDryingException
	 */
	protected abstract void startTypeRead(Class clazz) throws FreezeDryingException;

	/**
	 * Reads in a row of data that will be parsed by the use of {@link #getFieldValue(X, String)}
	 * and {@link #getFields(String)}.<p/>
	 * 
	 * If the data source can find an object with the specified key it should return data for
	 * reading that object, otherwise it may return any object.
	 * 
	 * @param clazz
	 *            the class the data will be used for
	 * @param key
	 *            the key of the object we're looking for, if null it should be ignored
	 * 
	 * @return a row of data
	 * @throws FreezeDryingException
	 */
	protected abstract X readRow(Class clazz, String key) throws FreezeDryingException;

	/**
	 * Reads in a byte[] that corresponds to the specified bytesId and will be loaded into the
	 * specified fdo through the specified field.
	 * 
	 * @param fdo
	 *            the object that the bytes are going to be stored in
	 * @param field
	 *            the field the bytes[] are for
	 * @param columnValue
	 *            the value in the row of data for the field (the return of a
	 *            {@link #writeByteArray(FreezeDryedObject, String, byte[])}
	 * @return the read in byte[]
	 * @throws FreezeDryingException
	 */
	protected abstract byte[] readByteArray(FreezeDryedObject fdo, String field, Object bytesId)
			throws FreezeDryingException;

	/**
	 * Retrieves the fields for a specified type. Generally these should be read in and stored
	 * during the {@link #startTypeRead(Class)} call.
	 * 
	 * @param type
	 *            the type of the {@link FreezeDryedObject} (from {@link #getType(Class)}).
	 * @return the list of fields of that type
	 * @throws FreezeDryingException
	 */
	protected abstract List<String> getFields(String type) throws FreezeDryingException;

	/**
	 * Retrieves the value of the specified field in the specified row of data.
	 * 
	 * @param row
	 *            the row (returned by {@link #readRow(Class)}).
	 * @param field
	 *            the field we're reading
	 * @return the value of that field
	 * @throws FreezeDryingException
	 */
	protected abstract Object getFieldValue(X row, String field) throws FreezeDryingException;

	/**
	 * Initializes the reading of the children of a specified {@link FreezeDryedObject}.
	 * 
	 * @param fdo
	 *            the {@link FreezeDryedObject} whose children will be read
	 * @throws FreezeDryingException
	 */
	protected abstract void startChildrenRead(FreezeDryedObject fdo) throws FreezeDryingException;

	/**
	 * Reads in a row of data about a child of the specified {@link FreezeDryedObject}.
	 * 
	 * @param parent
	 *            the parent of the child that will be read
	 * @param id
	 *            the id of the child we're concerned with
	 * @return a row of data on the child
	 */
	protected abstract X readChildsRow(FreezeDryedObject parent, String id)
			throws FreezeDryingException;

	/**
	 * Ends the reading of the children for the specified {@link FreezeDryedObject}.
	 * 
	 * @param fdo
	 *            the {@link FreezeDryedObject} whose children have been read
	 */
	protected abstract void finishChildrenRead(FreezeDryedObject fdo);

	/**
	 * Finishes the reading of the specified class.
	 * 
	 * @param clazz
	 *            the class whose reading has completed
	 */
	protected abstract void endTypeRead(Class clazz);

	private static final MessageCenter LOG = MessageCenter
			.getMessageCenter(AbstractDataSource.class);

  /**
   * Resets this data source.
   */
  public void reset() {}

  /**
   * Closes this data source.
   *
   * @throws FreezeDryingException
   */
  public void close() throws FreezeDryingException {}

  public void write(FreezeDryedObject object) throws FreezeDryingException {
		startTypeWrite(object);
		HashMap<String, Object> values = new HashMap<String, Object>();

		for (String[] pairs : getColumnKeysetPairs(object)) {
			Object value = object.get(pairs[0]);
			if (pairs[0] == ID_COL) {
				value = getValue(object.getId());
			} else if (value instanceof String) {
				value = getValue((String) value);
			} else if (value instanceof char[]) {
				value = getValue((char[]) value);
			} else if (value instanceof Number) {
				value = getValue((Number) value);
			} else if (value instanceof byte[]) {
				value = writeByteArray(object, pairs[0], (byte[]) value);
			} else if (value != null && FieldUtilities.INSTANCE.isPrimitiveArray(value.getClass())) {
				value = getValueArray(value);
			}
			if (value != null) {
				values.put(pairs[1], value);
			}
		}
		if (object.hasChildren()) {
			values.put(getChildrenColumnName(object), getChildrenName(object));
			writeChildren(object);
		}
		writeRow(object, values);

		finishTypeWrite(object);
	}

	protected String getValueArray(Object value) {
		return "\'"
				+ ArrayValueHandler.writeArray(value, PrimitiveArrayFreezeDryer.ELEMENT_DELIMITER)
				+ "\'"; 
	}

	private Object getChildrenName(FreezeDryedObject object) {
		return getValue(getType(object) + CHILDREN_MARKER);
	}

	protected void writeChildren(FreezeDryedObject fdo) throws FreezeDryingException {
		startChildrenWrite(fdo);

		HashMap<String, Object> child = new HashMap<String, Object>();

		for (FreezeDryedParentChild cfdo : fdo.getChildren()) {
			child.put(PARENT_ID_COL, fdo.getId());
			child.put(CHILD_CLASS_COL, cfdo.getChildClass().getName());
			child.put(CHILD_ID_COL, cfdo.getChildId());
			writeChildData(fdo, child);
		}

		finishChildrenWrite(fdo);
	}

	protected String getType(Class clazz) {
		return clazz.getName();
	}

	protected String getType(FreezeDryedObject object) {
		return getType(object.getType());
	}

	protected String getValue(String value) {
		return "\"" + StringEscapeUtils.escapeJava(value) + "\"";
		// return "\"" + StringEscapeUtils.escapeJava(value) + "\"";
		// return StringEscapeUtils.escapeJava(value);
	}

	protected String getValue(char[] value) {
		return getValue(new String(value));
	}

	protected String getValue(Number number) {
		return number.toString();
	}

	protected List<String> getColumns(FreezeDryedObject fdo) {
		List<String> fields = new ArrayList<String>();
		for (String[] name : getColumnKeysetPairs(fdo)) {
			fields.add(name[1]);
		}
		return fields;
	}

	protected String[] pair(String string1, String string2) {
		return new String[] { string1, string2 };
	}

	protected List<String[]> getColumnKeysetPairs(FreezeDryedObject fdo) {
		List<String[]> fields = new ArrayList<String[]>();
		
		fields.add(pair(ID_COL, ID_COL));
		for (String name : fdo.keySet()) {
			if (fdo.get(name) instanceof String
					|| FieldUtilities.INSTANCE.isPrimitive(fdo.get(name).getClass())) {
				fields.add(pair(name, name));
			} else if (FieldUtilities.INSTANCE.isPrimitiveArray(fdo.get(name).getClass())) {
				fields.add(pair(name, SPECIAL_COL_MARKER + name + ARRAY_MARKER
						+ fdo.get(name).getClass().getName()));
				LOG.info("Found array with name='" + name + "'");
			} else if (fdo.get(name) instanceof byte[]) {
				// writer.write("\"@" + name + "_filename\"");
				fields.add(pair(name, SPECIAL_COL_MARKER + name + BYTES_MARKER));
			} else if (fdo.get(name) instanceof FreezeDryedParentChild) {
				fields.add(pair(name, FreezeDryUtils.getClassColumn(name)));
				fields.add(pair(name, FreezeDryUtils.getIDColumn(name)));
			} else {
				LOG.warn("Unsupported field '" + name + "' in freeze dryed object's fields. Type '"
						+ fdo.get(name).getClass().getName() + "' not handled");
			}
		}
		if (fdo.hasChildren()) {
			String name = getChildrenColumnName(fdo);
			fields.add(pair(name, name));
		}
		return fields;
	}
	
	protected FreezeDryedObject parseRow(Class clazz, X row) throws FreezeDryingException {
		try {
			List<String> fields = getFields(getType(clazz));
			String id = null;

			FreezeDryedObject fdo = new FreezeDryedObject(clazz);

			HashMap<String, String> childsToRead = new HashMap<String, String>();

			for (int i = 0; i < fields.size(); i++) {
				String field = fields.get(i);
				Object val;
				try {
					 val = getFieldValue(row, field);
				} catch (RuntimeException ex) {
					if (isChildrenField(field)) {
						// this hopefully just means the item had no children
						LOG.info("Caught an exception when trying to read children '" + field
								+ "'.", ex);
						continue;
					}
					throw ex;
				}
				
				if (field.equals(ID_COL)
						|| field.regionMatches(false, 0, ID_COL, 1, ID_COL.length() - 2)) {
					fdo.setId((String) val);
					id = (String) val;
					continue;
				} else if (field.startsWith(SPECIAL_COL_MARKER)
						&& field.matches(ARRAY_MARKER + ".*\\Z")) {
					String trueFieldName = getTrueFieldName(field, ARRAY_MARKER);
					
					String arrayType = getArrayType(field);
					
					Object array = getArrayValue(arrayType, val);
					
					fdo.put(trueFieldName, array);
					continue;
					
				} else if (field.endsWith(CLASS_MARKER) || field.endsWith(CLASS_MARKER + "\"")) {
					// have to read in a FreezeDryedParentChild
					String trueFieldName = getTrueFieldName(field, CLASS_MARKER);

					childsToRead.put(trueFieldName, (String) val);
				} else if (field.endsWith(CHILD_ID_MARKER)
						|| field.endsWith(CHILD_ID_MARKER + "\"")) {
					String trueFieldName = getTrueFieldName(field, CHILD_ID_MARKER);

					String childId = (String) val;

					String className = childsToRead.get(trueFieldName);
					if (className != null) {
						FreezeDryedParentChild fdpc = readFreezeDryedParentChild(fdo, className,
								childId);
						fdo.put(trueFieldName, fdpc);

						childsToRead.remove(trueFieldName);
					} else {
						LOG
								.warn("Found a child id '"
										+ childId
										+ "'before finding its corresponding class name. The class name must be returned before the id.");
						// TODO: handle this as an error, the class column has to be found before
						// the child id column
					}
				} else if (isChildrenField(field)) {
					readChildren(fdo);
				} else if (field.endsWith(BYTES_MARKER) || field.endsWith(BYTES_MARKER + "\"")) {
					byte array[] = readByteArray(fdo, field, val);
					fdo.put(field.substring(1, field.indexOf(BYTES_MARKER)), array);
				}

				fdo.put(field, val);
			}
			if (id == null) {
				fdo.setId(UUID.randomUUID().toString());
			}
			if (childsToRead.size() > 0) {
				StringBuilder childrenUnread = new StringBuilder();
				for (String string : childsToRead.keySet()) {
					childrenUnread.append(string).append(",");
				}
				LOG.warn("Not all (child, childId) pairs were found.  For these classes ids weren't found:\n\t"
								+ childrenUnread.toString());
			}

			return fdo;
		} catch (ClassNotFoundException ex) {
			throw new FreezeDryingException(ex);
		}
	}

	protected Object getArrayValue(String arrayType, Object val) {
		return ArrayValueHandler.readArray(arrayType, (String) val,
				PrimitiveArrayFreezeDryer.ELEMENT_DELIMITER);
	}

	protected String getArrayType(String field) {
		return field.substring(field.indexOf(ARRAY_MARKER), field.length());
	}

	protected String getTrueFieldName(String field, String marker) {
		int offset = 0;
		if (field.startsWith("\"")) {
			offset++;
		}
		if (field.startsWith(SPECIAL_COL_MARKER)) {
			offset += SPECIAL_COL_MARKER.length();
		}
		
		return field.substring(offset, field.indexOf(marker));
	}
	
	private boolean isChildrenField(String field) {
		return field.endsWith(CHILDREN_MARKER)
				|| field.endsWith(CHILDREN_MARKER + "\"");
	}

	protected FreezeDryedParentChild readFreezeDryedParentChild(FreezeDryedObject parent,
			String className, String childId) throws ClassNotFoundException {
		FreezeDryedParentChild child = new FreezeDryedParentChild(parent.getType(), parent.getId());
		Class childClass = FieldUtilities.INSTANCE.getClassFromString(className);
		child.setChildClass(childClass);
		child.setChildId(childId);

		return child;
	}

	protected void readChildren(FreezeDryedObject fdo) throws ClassNotFoundException,
			FreezeDryingException {
		startChildrenRead(fdo);

		try {
			X childsRow = null;

			while ((childsRow = readChildsRow(fdo, fdo.getId())) != null) {
				FreezeDryedParentChild fdpc = parseChildRow(fdo, childsRow);

				// make sure the id's matched up
				if (fdpc != null) {
					fdo.addChild(fdpc);
				}
			}
		} finally {
			finishChildrenRead(fdo);
		}

	}

	protected FreezeDryedParentChild parseChildRow(FreezeDryedObject fdo, X childsRow)
			throws ClassNotFoundException, FreezeDryingException {
		FreezeDryedParentChild fdpc = new FreezeDryedParentChild(fdo.getType(), fdo.getId());

		String parentId = getFieldValue(childsRow, PARENT_ID_COL).toString();
		if (!parentId.equals(fdo.getId())) {
			return null;
		}

		Class childClass = Class.forName(getFieldValue(childsRow, CHILD_CLASS_COL).toString());
		String childId = getFieldValue(childsRow, CHILD_ID_COL).toString();

		fdpc.setChildClass(childClass);
		fdpc.setChildId(childId);

		return fdpc;
	}

	public FreezeDryedObject read(Class clazz, String key) throws FreezeDryingException {
		try {
			startTypeRead(clazz);

			X row = null;
			while ((row = readRow(clazz, key)) != null) {
				FreezeDryedObject fdo = parseRow(clazz, row);
				if (fdo.getId().equals(key)) {
					return fdo;
				}
			}

			return null;
		} catch (Exception e) {
			throw new FreezeDryingException(e);
		} finally {
			endTypeRead(clazz);
		}
	}

	public Iterable<FreezeDryedObject> read(Class clazz) throws FreezeDryingException {
		List<FreezeDryedObject> out = new ArrayList<FreezeDryedObject>();

		try {
			startTypeRead(clazz);

			X row = null;
			while ((row = readRow(clazz, null)) != null) {
				FreezeDryedObject fdo = parseRow(clazz, row);
				out.add(fdo);
			}

			return out;
		} catch (Exception e) {
			throw new FreezeDryingException(e);
		} finally {
			endTypeRead(clazz);
		}
	}

	protected String getChildrenColumnName(FreezeDryedObject fdo) {
		return SPECIAL_COL_MARKER + getType(fdo) + CHILDREN_MARKER;
	}
}
